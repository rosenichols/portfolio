<?php

/**
 * Implements hook_permission().
 *
 * @return type 
 */
function taxonomy_extras_permission() {
  return array(
    'reorder taxonomy nodes' => array(
      'title' => t('Re Order Taxonomy Nodes By Weight'),
      'description' => t('Re Order Taxonomy Nodes By Weight'),
    ),
  );
}

/**
 * Implements hook_views_api().
 *
 * @return type 
 */
function taxonomy_extras_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'taxonomy_extras'),
    'template path' => drupal_get_path('module', 'taxonomy_extras'),
  );
}

/**
 * Implements hook_menu().
 *
 * @return array 
 */
function taxonomy_extras_menu() {

  $items['taxonomy/term/%taxonomy_term/order'] = array(
    'access callback' => '_taxonomy_extras_access_callback',
    'access arguments' => array(2),
    'page callback' => '_taxonomy_extras_page_callback',
    'page arguments' => array(2),
    'title' => 'Re-order content',
    'weight' => 10,
    'type' => MENU_LOCAL_TASK,
  );


  // Main menu item.
  $items['admin/appearance/taxonomy_extras'] = array(
    'title' => 'Taxonomy Settings',
    'description' => 'Taxonomy Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_extras_settings'),
    'access arguments' => array('administer themes'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  );

  // Global library configuration tab.
  $items['admin/appearance/taxonomy_extras/global'] = array(
    'title' => 'Global settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );

  // Add a local task for each available theme.
  foreach (list_themes() as $theme) {
    $items['admin/appearance/taxonomy_extras/' . $theme->name] = array(
      'title' => $theme->info['name'],
      'page arguments' => array('taxonomy_extras_settings', $theme->name),
      'type' => MENU_LOCAL_TASK,
      'access callback' => '_system_themes_access',
      'access arguments' => array($theme),
    );
  }


  return $items;
}

/*
 * Build the settings form.
 *
 * @param array $form
 *   Nested array of form elements that comprise the form.
 * @param array $form_state
 *   A keyed array containing the current state of the form.
 */

function taxonomy_extras_settings($form, &$form_state, $key = 'global') {

  // Save the current theme name in the form state.
  $form_state['theme_key'] = $key;

  // Retrieve the settings for all themes.
  $all_settings = variable_get('taxonomy_extras_settings');

  // Get the settings for a specific theme
  if (isset($all_settings[$key])) {
    $settings = $all_settings[$key];
  }
  else {
    $settings = array();
  }

  $form['taxonomy_extras'] = array(
    '#type' => 'container',
    '#tree' => TRUE
  );

  $vocabulary = taxonomy_get_vocabularies();
  $checklist_vocab_array = array(); /* Change to array('0' => '--none--'); if you want a none option */
  foreach ($vocabulary as $item) {
    $key = $item->vid;
    $value = $item->name;
    $checklist_vocab_array[$key] = $value;


    $form['taxonomy_extras'][$key] = array(
      '#type' => 'fieldset',
      '#title' => t('') . $value,
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => array(
        'class' => array(
          ''
        )
      )
    );

    $form['taxonomy_extras'][$key]['manage'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable Weight Management'),
      '#description' => t('Shows a link to re-order the content when viewing a term'),
      '#default_value' => (isset($settings['taxonomy_extras'][$key]['manage']) ? $settings['taxonomy_extras'][$key]['manage'] : 0),
    );
    $form['taxonomy_extras'][$key]['children'] = array(
      '#type' => 'container',
      '#title' => 'Taxonomy Children',
      '#attributes' => array(
        'class' => array(
        )
      )
    );

    $form['taxonomy_extras'][$key]['children']['display'] = array(
      '#title' => t('Child Term View Mode'),
      '#type' => 'select',
      '#description' => t('Choose the view mode to use when displaying taxonomy child terms'),
      '#options' => _taxonomy_extras_view_modes('taxonomy_term'),
      '#default_value' => (isset($settings['taxonomy_extras'][$key]['children']['display']) ? $settings['taxonomy_extras'][$key]['children']['display'] : 'teaser'),
    );



    $form['taxonomy_extras'][$key]['nodes'] = array(
      '#title' => 'Taxonomy Nodes',
      '#type' => 'container',
      '#attributes' => array(
        'class' => array(
        )
      )
    );

    $form['taxonomy_extras'][$key]['nodes']['display'] = array(
      '#title' => t('Node View Mode'),
      '#type' => 'select',
      '#description' => t('Taxonomy nodes view mode'),
      '#options' => _taxonomy_extras_view_modes('node'),
      '#default_value' => (isset($settings['taxonomy_extras'][$key]['nodes']['display']) ? $settings['taxonomy_extras'][$key]['nodes']['display'] : 'teaser'),
    );

    $form['taxonomy_extras'][$key]['nodes']['type'] = array(
      '#title' => t('Nodes to Include'),
      '#type' => 'select',
      '#description' => t('Taxonomy nodes type'),
      '#options' => array('default' => 'Default', 'nodes_depth' => 'Nodes With Children', 'nodes_by_weight' => 'Nodes By Weight'),
      '#default_value' => (isset($settings['taxonomy_extras'][$key]['nodes']['type']) ? $settings['taxonomy_extras'][$key]['nodes']['type'] : 'default'),
    );



    $form['taxonomy_extras'][$key]['misc'] = array(
      '#title' => 'Miscellaneous Settings',
      '#type' => 'container',
      '#attributes' => array(
        'class' => array(
        )
      )
    );

    $form['taxonomy_extras'][$key]['misc']['qty'] = array(
      '#type' => 'textfield',
      '#title' => t('How many terms per page'),
      '#default_value' => (isset($settings['taxonomy_extras'][$key]['misc']['qty']) ? $settings['taxonomy_extras'][$key]['misc']['qty'] : 10),
    );

    $form['taxonomy_extras'][$key]['misc']['empty'] = array(
      '#type' => 'textfield',
      '#title' => t('No Results Text'),
      '#default_value' => (isset($settings['taxonomy_extras'][$key]['misc']['empty']) ? $settings['taxonomy_extras'][$key]['misc']['empty'] : 'No content classified for this term'),
    );
  }


  // Reccomend extra template suggestions
  // Submit button.
  $form['actions']['#type'] = 'actions';
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save configuration'),
  );

  // Display an error message if the settings cant be saved
  if (!empty($_POST) && form_get_errors()) {
    drupal_set_message(t('The settings have not been saved because of the errors.'), 'error');
  }
  // Add a submit handler to save the settings.
  $form['#submit'][] = 'taxonomy_extras_theme_settings_submit';
  // Render the form using theme_system_settings_form().
  $form['#theme'] = 'system_settings_form';

  return $form;
}

function _taxonomy_extras_view_modes($entity_type) {
  $entity_info = entity_get_info($entity_type);

  $options = array();
  foreach ($entity_info['view modes'] as $key => $value) {
    $options[$key] = $value['label'];
  }
  return $options;
}

/**
 * Menu Page Callback
 * @param object $term 
 */
function _taxonomy_extras_page_callback($term) {
  drupal_goto('admin/taxonomy-weight/' . $term->tid);
}

/**
 * Menu Access Callback
 *
 * @param object $term
 * @return boolean 
 */
function _taxonomy_extras_access_callback($term) {



  // Retrieve the current theme name.
  $current_theme = variable_get('theme_default', 'none');

  // Retrieve the settings for all themes.
  $all_settings = variable_get('taxonomy_extras_settings');

  // Get the settings for a specific theme
  if (isset($all_settings[$current_theme])) {
    $settings = $all_settings[$current_theme];
  }
  else {
    $settings = array();
    return FALSE;
  }


  return user_access('reorder taxonomy nodes') && $settings['taxonomy_extras'][$term->vid]['manage'];
}

/**
 * Implements hook_menu_alter().
 *
 * @param string $items 
 */
function taxonomy_extras_menu_alter(&$items) {
  if (!empty($items['taxonomy/term/%taxonomy_term'])) {
    $items['taxonomy/term/%taxonomy_term']['page callback'] = 'taxonomy_extras_taxonomy_term_page';
  }
}

/**
 * Return nodes attached to a term across all field instances.
 *
 * This function requires taxonomy module to be maintaining its own tables,
 * and will return an empty array if it is not. If using other field storage
 * methods alternatives methods for listing terms will need to be used.
 *
 * @param $tid
 *   The term ID.
 * @param $pager
 *   Boolean to indicate whether a pager should be used.
 * @param $limit
 *   Integer. The maximum number of nodes to find.
 *   Set to FALSE for no limit.
 * @param $order
 *   An array of fields and directions.
 *
 * @return
 *   An array of nids matching the query.
 */
function _taxonomy_select_nodes_by_weight($tid, $pager = TRUE, $limit = FALSE, $order = array('t.sticky' => 'DESC', 't.created' => 'DESC')) {
  if (!variable_get('taxonomy_maintain_index_table', TRUE)) {
    return array();
  }
  $query = db_select('taxonomy_index', 't');
  $query->addTag('node_access');
  $query->condition('tid', $tid);
  if ($pager) {
    $count_query = clone $query;
    $count_query->addExpression('COUNT(t.nid)');

    $query = $query->extend('PagerDefault');
    if ($limit !== FALSE) {
      $query = $query->limit($limit);
    }
    $query->setCountQuery($count_query);
  }
  else {
    if ($limit !== FALSE) {
      $query->range(0, $limit);
    }
  }
  $query->addField('t', 'nid');
  $query->join('weight_weights', 'w', 'w.entity_id = t.nid');
  $query->addField('t', 'tid');
  $query->orderBy('w.weight', 'ASC');
  foreach ($order as $field => $direction) {
    $query->orderBy($field, $direction);
    // ORDER BY fields need to be loaded too, assume they are in the form
    // table_alias.name
    list($table_alias, $name) = explode('.', $field);
    $query->addField($table_alias, $name);
  }
  return $query->execute()->fetchCol();
}

function taxonomy_extras_field_extra_fields() {

  $return = array();
  $info = entity_get_info('taxonomy_term');

  foreach (array_keys($info['bundles']) as $bundle) {
    $return['taxonomy_term'][$bundle]['display']['title'] = array(
      'label' => t('Title'),
      'description' => t('Title'),
      'weight' => -5,
    );



    $return['taxonomy_term'][$bundle]['display']['taxonomy_children'] = array(
      'label' => t('Taxonomy Child Terms'),
      'description' => t('Child Taxonomy Terms'),
      'weight' => 2,
    );

    $return['taxonomy_term'][$bundle]['display']['taxonomy_nodes'] = array(
      'label' => t('Nodes attached to this term'),
      'description' => t('Nodes attached to this term'),
      'weight' => 1,
    );
  }

  return $return;
}

/**
 * Return nodes attached to a term across all field instances.
 *
 * This function requires taxonomy module to be maintaining its own tables,
 * and will return an empty array if it is not. If using other field storage
 * methods alternatives methods for listing terms will need to be used.
 *
 * @param $tid
 *   The term ID.
 * @param $pager
 *   Boolean to indicate whether a pager should be used.
 * @param $limit
 *   Integer. The maximum number of nodes to find.
 *   Set to FALSE for no limit.
 * @param $order
 *   An array of fields and directions.
 *
 * @return
 *   An array of nids matching the query.
 */
function taxonomy_select_nodes_original($tid, $pager = TRUE, $limit = FALSE, $order = array('t.sticky' => 'DESC', 't.created' => 'DESC')) {
  if (!variable_get('taxonomy_maintain_index_table', TRUE)) {
    return array();
  }
  $query = db_select('taxonomy_index', 't');
  $query->addTag('node_access');
  $query->condition('tid', $tid);
  if ($pager) {
    $count_query = clone $query;
    $count_query->addExpression('COUNT(t.nid)');

    $query = $query->extend('PagerDefault');
    if ($limit !== FALSE) {
      $query = $query->limit($limit);
    }
    $query->setCountQuery($count_query);
  }
  else {
    if ($limit !== FALSE) {
      $query->range(0, $limit);
    }
  }
  $query->addField('t', 'nid');
  $query->addField('t', 'tid');
  foreach ($order as $field => $direction) {
    $query->orderBy($field, $direction);
    // ORDER BY fields need to be loaded too, assume they are in the form
    // table_alias.name
    list($table_alias, $name) = explode('.', $field);
    $query->addField($table_alias, $name);
  }
  return $query->execute()->fetchCol();
}

function taxonomy_extras_taxonomy_term_view(&$term, $view_mode, $langcode) {

  // Retrieve the current theme name.
  $current_theme = variable_get('theme_default', 'none');

  // Retrieve the settings for all themes.
  $all_settings = variable_get('taxonomy_extras_settings');

  // Get the settings for a specific theme
  if (isset($all_settings[$current_theme])) {
    $settings = $all_settings[$current_theme];
  }
  else {
    $settings = array();
  }

  $nids = array();


  // calculate how many terms we should load
  if (isset($settings['taxonomy_extras']) && isset($settings['taxonomy_extras'][$term->vid]['misc']['qty'])) {
    $qty = $settings['taxonomy_extras'][$term->vid]['misc']['qty'];
  }
  else {
    $qty = 10;
  }


  $nids = array();
  $build = array();

  if (isset($settings['taxonomy_extras'][$term->vid])) {
      $mode = $settings['taxonomy_extras'][$term->vid]['nodes']['type'];
  } else {
    $mode = 'default';
  }



  if ($mode == 'default') {
    $nids = taxonomy_select_nodes_original($term->tid, TRUE, $qty, array('t.created' => 'DESC'));
  }
  else if ($mode == 'nodes_depth') {
    $nids = _taxonomy_select_nodes_original_with_children($term->tid, TRUE, $qty, array('t.created' => 'DESC'));
  }
  else if ($mode == 'nodes_by_weight') {
    $nids = _taxonomy_select_nodes_by_weight($term->tid, TRUE, $qty, array('t.created' => 'DESC'));
  }
  else {
    return NULL;
  }

  if ($nids) {
    $nodes = node_load_multiple($nids);
    $build = node_view_multiple($nodes, $settings['taxonomy_extras'][$term->vid]['nodes']['display']);

    $build['pager'] = array(
      '#theme' => 'pager',
      '#weight' => 5,
    );
  }
  else {
    $build['no_content'] = array(
      '#prefix' => '<p>',
      '#markup' => isset($settings['taxonomy_extras']) ? $settings['taxonomy_extras'][$term->vid]['misc']['empty'] : 'none',
      '#suffix' => '</p>',
    );
  }



  $term->content['taxonomy_nodes'] = $build;

  $build = array();

  $settings = _taxonomy_extras_get_active_settings();

  // Find all nodes attached to this taxonomy term.
  $childs = taxonomy_get_children($term->tid, $term->vid);

  if (!empty($childs)) {
    $build = array(
      '#type' => 'container',
      '#attributes' => array(
        'class' => array('taxonomy-children')
      )
    );
    foreach ($childs as $theterm) {
      $build[$theterm->tid] = taxonomy_term_view($theterm, $settings['taxonomy_extras'][$theterm->vid]['children']['display']);
      
   
      
      
    }
  }



  // Add the taxonomy children as a template variable.
  $term->content['taxonomy_children'] = $build;
}

/**
 * Menu callback; displays all nodes associated with a term.
 *
 * @param $term
 *   The taxonomy term.
 * @return
 *   The page content.
 */
function taxonomy_extras_taxonomy_term_page($term) {

  // Retrieve the current theme name.
  $current_theme = variable_get('theme_default', 'none');

  // Retrieve the settings for all themes.
  $all_settings = variable_get('taxonomy_extras_settings');

  // Get the settings for a specific theme
  if (isset($all_settings[$current_theme])) {
    $settings = $all_settings[$current_theme];
  }
  else {
    $settings = array();
  }


  // @todo if the current term is part of a vocaublary that has no weight 
  // enabled content types referncing it then return the original term page.
  // Assign the term name as the page title.
  drupal_set_title($term->name);

  // Build breadcrumb based on the hierarchy of the term.
  $current = (object) array(
        'tid' => $term->tid,
  );
  // @todo This overrides any other possible breadcrumb and is a pure hard-coded
  //   presumption. Make this behavior configurable per vocabulary or term.
  $breadcrumb = array();
  while ($parents = taxonomy_get_parents($current->tid)) {
    $current = array_shift($parents);
    $breadcrumb[] = l($current->name, 'taxonomy/term/' . $current->tid);
  }
  $breadcrumb[] = l(t('Home'), NULL);
  $breadcrumb = array_reverse($breadcrumb);
  drupal_set_breadcrumb($breadcrumb);
  drupal_add_feed('taxonomy/term/' . $term->tid . '/feed', 'RSS - ' . $term->name);

  $build = array();

  $build['term_heading'] = array(
    'term' => taxonomy_term_view($term, 'full'),
  );
  return $build;
}

/**
 * Custom Submit handler for the theme settings form.
 *
 * @param array $form
 *   Nested array of form elements that comprise the form.
 * @param array $form_state
 *   A keyed array containing the current state of the form.
 */
function taxonomy_extras_theme_settings_submit($form, &$form_state) {

  $data_to_save = variable_get('taxonomy_extras_settings');

  // Remove internal Form API values.
  unset($form_state['values']['form_id'], $form_state['values']['form_token'], $form_state['values']['form_build_id'], $form_state['values']['op'], $form_state['values']['submit']
  );

  // Retrieve the current theme name that was saved when the form was defined.
  $theme = $form_state['theme_key'];

  // Wipe the settings.
  $data_to_save[$theme] = array();

  foreach ($form_state['values'] as $key => $value) {
    if (is_array($value) && isset($form_state['values']['array_filter'])) {
      $value = array_keys(array_filter($value));
    }
    $data_to_save[$theme][$key] = $value;
  }

  // Save the settings.
  variable_set('taxonomy_extras_settings', $data_to_save);

  drupal_set_message(t('The configuration options have been saved.'));
}

function _taxonomy_extras_get_active_settings() {
  // Retrieve the current theme name.
  $current_theme = variable_get('theme_default', 'none');

  // Retrieve the settings for all themes.
  $all_settings = variable_get('taxonomy_extras_settings');

  // Get the settings for a specific theme
  if (isset($all_settings[$current_theme])) {
    $settings = $all_settings[$current_theme];
  }
  else {
    $settings = array();
  }
  return $settings;
}

function _taxonomy_select_nodes_original_with_children($tid, $pager = TRUE, $limit = FALSE, $order = array('t.sticky' => 'DESC', 't.created' => 'DESC')) {
  global $pager_page_array, $pager_total;



  if (!variable_get('taxonomy_maintain_index_table', TRUE)) {
    return array();
  }
  $children = array();

  $children = array_keys(taxonomy_get_children($tid));

  array_unshift($children, $tid);


  $query = db_select('taxonomy_index', 't');
  $query->addTag('node_access');
  $query->condition('tid', $children);
  if ($pager) {
    $count_query = clone $query;
    $count_query->addExpression('COUNT(t.nid)');


    $query = $query->extend('PagerDefault');


    if ($limit !== FALSE) {
      $query = $query->limit($limit);
    }
    $query->setCountQuery($count_query);
  }
  else {
    if ($limit !== FALSE) {
      $query->range(0, $limit);
    }
  }
  $query->addField('t', 'nid');
  $query->addField('t', 'tid');
  foreach ($order as $field => $direction) {
    $query->orderBy($field, $direction);
    // ORDER BY fields need to be loaded too, assume they are in the form
    // table_alias.name
    list($table_alias, $name) = explode('.', $field);
    $query->addField($table_alias, $name);
  }

  return $query->execute()->fetchCol();
}

